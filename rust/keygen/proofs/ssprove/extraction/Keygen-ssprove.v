(* File automatically generated by Hacspec *)
Set Warnings "-notation-overridden,-ambiguous-paths".
From Crypt Require Import choice_type Package Prelude.
Import PackageNotation.
From extructures Require Import ord fset.
From mathcomp Require Import word_ssrZ word.
From Jasmin Require Import word.

From Coq Require Import ZArith.
From Coq Require Import Strings.String.
Import List.ListNotations.
Open Scope list_scope.
Open Scope Z_scope.
Open Scope bool_scope.

From Hacspec Require Import ChoiceEquality.
From Hacspec Require Import LocationUtility.
From Hacspec Require Import Hacspec_Lib_Comparable.
From Hacspec Require Import Hacspec_Lib_Pre.
From Hacspec Require Import Hacspec_Lib.

Open Scope hacspec_scope.
Import choice.Choice.Exports.

Obligation Tactic := (* try timeout 8 *) solve_ssprove_obligations.

Require Import Rng.
Export Rng.

Notation "'t_Nat'" := int64.

(*Not implemented yet? todo(item)*)

(*Not implemented yet? todo(item)*)

Equations apply {L1 : {fset Location}} {L2 : {fset Location}} {I1 : Interface} {I2 : Interface} {v_F : _} `{ t_Sized v_F} `{ t_FnOnce v_F int64} (f : both L1 I1 v_F) (sk : both L2 I2 int64) : both (L1 :|: L2) (I1 :|: I2) int64 :=
  apply f sk  :=
    solve_lift (f_call_once f sk) : both (L1 :|: L2) (I1 :|: I2) int64.
Fail Next Obligation.

Equations example_function {L1 : {fset Location}} {I1 : Interface} (sk : both L1 I1 int64) : both L1 I1 int64 :=
  example_function sk  :=
    solve_lift (sk .+ (ret_both (0 : int64))) : both L1 I1 int64.
Fail Next Obligation.

Equations key_gen {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 'unit) : both L1 I1 (int64 × int64) :=
  key_gen _  :=
    letb '(_,out) := f_gen (thread_rng (ret_both (tt : 'unit))) in
    letb sk := out in
    letb '(_,out) := f_gen (thread_rng (ret_both (tt : 'unit))) in
    letb pk := out in
    solve_lift (prod_b (sk,pk)) : both L1 I1 (int64 × int64).
Fail Next Obligation.

Equations main {L1 : {fset Location}} {I1 : Interface} (_ : both L1 I1 'unit) : both L1 I1 'unit :=
  main _  :=
    letb '(sk,pk) := key_gen (ret_both (tt : 'unit)) in
    letb _ := v__print (impl_2__new_v1 (unsize (array_from_list [ret_both (Public Key (pk):  : chString);
      ret_both (
 : chString)])) (unsize (array_from_list [impl_1__new_display pk]))) in
    letb _ := ret_both (tt : 'unit) in
    letb result := apply example_function sk in
    letb _ := v__print (impl_2__new_v1 (unsize (array_from_list [ret_both (Result:  : chString);
      ret_both (
 : chString)])) (unsize (array_from_list [impl_1__new_display result]))) in
    letb _ := ret_both (tt : 'unit) in
    solve_lift (ret_both (tt : 'unit)) : both L1 I1 'unit.
Fail Next Obligation.
