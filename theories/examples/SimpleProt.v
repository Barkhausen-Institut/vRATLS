(** *Introduction

In order to get into SSProve, it makes sense to look at a "simple" protocol
implementation and its verification.
I took this file straight from 'ssprove/theories/Crypt/examples/SigmaProtocol.v' and copied it here such
that I/we can add comments that will help us to understand.
*)
From Relational Require Import OrderEnrichedCategory GenericRulesSimple.

Set Warnings "-notation-overridden,-ambiguous-paths".
From mathcomp Require Import all_ssreflect all_algebra reals distr realsum
  fingroup.fingroup solvable.cyclic prime ssrnat ssreflect ssrfun ssrbool ssrnum
  eqtype choice seq.
Set Warnings "notation-overridden,ambiguous-paths".


From Crypt Require Import Axioms ChoiceAsOrd SubDistr Couplings
  UniformDistrLemmas FreeProbProg Theta_dens RulesStateProb UniformStateProb
  pkg_core_definition choice_type pkg_composition pkg_rhl
  Package Prelude RandomOracle.

From Coq Require Import Utf8.
From extructures Require Import ord fset fmap.
Require Import Lia.

From Equations Require Import Equations.
Require Equations.Prop.DepElim.

Set Equations With UIP.

Set Bullet Behavior "Strict Subproofs".
Set Default Goal Selector "!".
Set Primitive Projections.

Import Num.Def.
Import Num.Theory.
Import Order.POrderTheory.

Import PackageNotation.

#[local] Open Scope ring_scope.
Import GroupScope GRing.Theory.

(** Simple scheme: Diffie Hellmann Key Exchange

The scheme: A, B agree on prime p and element g \in group G = Z_p

    A:                          B:
sample a from G
A = g^a          ----A --->
                             sample b from G
                             B = g^b
                <----B-----
k=B^a                        k'=A^b

Lemma: k = k'
**)

Locate ">".
Print cycle_group. (* Has Notation <[ g ]> *)

Locate "#[".
Print order.

(*
  The math part:
 *)
Module Type GroupParams.

  (* Read:
https://math-comp.github.io/htmldoc/mathcomp.fingroup.fingroup.html
   *)
  Parameter gT : finGroupType.            (* We need a group type of finite size. *)
  Definition ζ : {set gT} := [set : gT].  (* The group [Z_p] is a set of type finite group type. *)
  Parameter g :  gT.                      (* This is the group element [g]. *)
  Parameter g_gen : ζ = <[g]>.            (* Predicate: [Z_p] is equal to the cyclic subgroup generated by [g]. *)
  Parameter prime_order : prime #[g].     (* Property: The order of the group generated from [g] is a prime number. *)

End GroupParams.

Module Type DiffieHellmannProtocolParams.

  Parameter Space: finType.
  Parameter Space_pos : Positive #|Space|.

End DiffieHellmannProtocolParams.


(*
  Here, we would define abstractions.
 *)
Module Type SigmaProtocolAlgorithms (DDHP : DiffieHellmannProtocolParams) (GP : GroupParams).

  Import DDHP.
  Import GP.

  #[local] Open Scope package_scope.

  #[local] Existing Instance Space_pos.

  (* We need to prove that #|GroupSpace| is positive. *)
  Definition GroupSpace : finType := FinGroup.arg_finType gT.
  #[local] Instance GroupSpace_pos : Positive #|GroupSpace|.
  Proof.
    apply /card_gt0P; by exists g.
  (* Needs to be transparent to unify with local positivity proof? *)
  Defined.

  Definition chGroup : choice_type := 'fin #|GroupSpace|.
  Notation " 'group " := (chGroup) (in custom pack_type at level 2).

  (* [p] itself is derived from the DiffieHellmann Parameters. *)
  Definition p := #|Space|.
  #[export] Instance p_pos : Positive p.
  Proof.
    unfold p. exact Space_pos.
  Defined.
  Definition chPElem : choice_type := 'fin p.

  Parameter Protocol_locs : {fset Location}.    (* | Here I will note all the steps of the protocol *)
  Parameter Simulator_locs : {fset Location}.   (* | This is for the simulator || not used yet *)

  (*
  Parameter Simulate :
    ∀ (g : choicePubKey) (sk_A : choicePrivKey) (sk_B : choicePrivKey),
      code Simulator_locs [interface] choiceTranscript.
   *)

End SigmaProtocolAlgorithms.

Module SigmaProtocol
  (DDHP : DiffieHellmannProtocolParams)
  (GP : GroupParams)
  (Alg : SigmaProtocolAlgorithms DDHP GP).

  Import Alg.
  Import GP. (* We actually only need [g], the group. *)

  (* This is a trick to give names to functions. *)
  Definition DDH : nat := 0.

  (* I want to store some elements of the group in the state. *)
  Definition sk_A : Location := (chPElem ; 0%N).
  Definition sk_B : Location := (chPElem ; 1%N).
  Definition fk : Location := (chPElem ; 2%N).

  (* Definition L__0 := fset [:: sk_A ; sk_B ; fk]. *)
  (* Using [L__0 ≔ fset[:: sk_A ; sk_B] ] here will make the proof more complicated because then
     we need to use another invariant over the heap. *)
  Definition L__0 := fset [:: sk_A ; sk_B].
  Definition L__1 := L__0 :|: fset [:: fk].

  #[local] Open Scope package_scope.

  Print fto.

  (* We need these definitions multiple times below.
     So just define them once here.
     Note that a game package needs to export a procedure of type ['unit → t] where [t] is some choice type.
   *)
  Definition Game__Import : Interface := [interface].
  Definition Game__Export : Interface := [interface #val #[ DDH ] : 'unit → 'group × 'group × 'group].

  Definition DH__real:
    package L__0
      Game__Import Game__Export
  :=
  [package
    #def #[ DDH ] (_ : 'unit) : 'group × 'group × 'group
    {
      (* Initially the state locations are empty. Let's fill them: *)
      sk_alice ← sample uniform p ;;
      sk_bob ← sample uniform p ;;
      #put sk_A := sk_alice ;;
      #put sk_B := sk_bob ;;

      (* Now, let's start with the protocol. *)

      (* Alice side: ephemeral key gen *)
      sk_alice' ← get sk_A ;;
      let e_a := (g^+ sk_alice') in

      (* Bob side: ephemeral key gen *)
      sk_bob' ← get sk_B ;;
      let e_b := (g^+ sk_bob') in

      (*
        If we want to model this properly then we would also have a state
        for the communication between Alice and Bob.
        Right now, the [Send_EphKey] function does not make much sense.
        It is essentially just [id].
       *)
      (*
      e_a_at_bob ← Send_EphKey e_a ;;
      e_b_at_alice ← Send_EphKey e_b ;;
       *)
      let e_a_at_bob := e_a in
      let e_b_at_alice := e_b in

      (* Alice side: final key gen *)
      let fk_alice := (e_b_at_alice^+ sk_alice') in

      (* Bob side: final key gen *)
      let fk_bob := (e_a_at_bob^+ sk_bob') in

      (* To reason about the correctness of the protocol/program
         just use assertions (of type [bool] not [Prop]!):
       *)
      (*
      [assert (fk_alice == fk_bob) ;;]
      Lesson learned: Don't define assertions that you do not use later on the code.
      The "ideal" package will need to define those too.
       *)

      (* Lesson learned:
         If the states look the same then I have to treat them in the same way.
         It is currently not possible to remove "lonely" [put] calls.

         I cannot put [fk_alice] blindly because obviously the type is not the
         same as for yet another value sampled from the distribution.
         [#put fk := fk_alice ;;]
       *)

      (* Our output here is essentially our communication, i.e.,
         everything that the attacker should be able to see but hopefully
         not be able to recover.
       *)
      ret (fto e_a , (fto e_b, fto fk_alice))
    }
  ].

  (** *** Simulated implementation
      Here, we really remove all the noise and just perform the mathematic
      operations.
   *)

  Lemma sk_A_in_L__1: sk_A \in L__1.
  Proof.
    unfold L__1. unfold L__0. (* Search "in_fset". *)
    rewrite in_fsetU. (* Locate "||". Print orb. Search "fset". *)
    apply /orP. left.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite in_fset1.
    apply /eqP.
    reflexivity.
  Qed.

  Lemma sk_B_in_L__1: sk_B \in L__1.
  Proof.
    unfold L__1. unfold L__0.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. right.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite in_fset1.
    apply /eqP.
    reflexivity.
  Qed.

  Lemma fk_in_L__1: fk \in L__1.
  Proof.
    unfold L__1. unfold L__0.
    rewrite in_fsetU.
    apply /orP. right.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite in_fset1.
    apply /eqP.
    reflexivity.
  Qed.


  Definition DH__ideal: package L__1 Game__Import Game__Export.
    refine(
        [package
           #def #[ DDH ] (_ : 'unit) : 'group × 'group × 'group
           {
             a ← sample uniform p ;;
             b ← sample uniform p ;;
             c ← sample uniform p ;;

             #put sk_A := a ;;
             #put sk_B := b ;;
             (* This was interesting:
                When not putting [c] into the state, I received a cryptic error message.
                It seems everything that was sampled needs to go into the state otherwise
                the package is not valid.
              *)
             #put fk := c ;;

             (* We are saying the an attacker would not be able to differentiate between
                our computed result and a randomly chosen one. *)
             ret (fto (g^+ a), (fto (g^+ b), fto (g^+ c)))
         }
      ]).
     ssprove_valid.
    - apply sk_A_in_L__1.
    - apply sk_B_in_L__1.
    - apply fk_in_L__1 .
  Defined.

  (* There is also a way to package a defined ValidCode into a ValidPackage.
     This does not work in the above case because the return type differ.
   *)
  Equations ddh_ideal : code L__1 [interface]
                     (prod_choiceType
                        (prod_choiceType
                           (FinGroup.choiceType gT)
                           (FinGroup.choiceType gT))
                        (FinGroup.choiceType gT)) :=
  ddh_ideal := {code
           a ← sample uniform p ;;
           b ← sample uniform p ;;
           c ← sample uniform p ;;

           #put sk_A := a ;;
           #put sk_B := b ;;
           #put fk := c ;;

           ret ((g^+ a), (g^+ b), (g^+ c))
      }.
  Next Obligation.
    ssprove_valid.
    - apply sk_A_in_L__1.
    - apply sk_B_in_L__1.
    - apply fk_in_L__1 .
  Defined.

  (* It is also possible to extend the ssprove_valid db
     with hints for the lemmas.
   *)

  Check AdvantageE.

  (*
    Now, I can define an advantage, i.e., a game.
    An attacker (package) [A] can not distinguish between the two (package) versions.
   *)
  Definition ɛ__DH A := AdvantageE DH__real DH__ideal A.

  (* The exported interface for running the game via the attacker package is
     predefined for us by SSProve.
   *)
  Check A_export.

  Lemma ignored_is_subset : fsubset (fset [:: fk]) (L__0 :|: L__1).
  Proof.
    unfold fsubset. rewrite fset_cons. unfold L__1. rewrite <- fset0E. rewrite fsetUC.
    rewrite fsetUA. rewrite fset_cons. rewrite <- fset0E. rewrite fsetU0.
    rewrite fsetUA. rewrite fset1E. rewrite fsetUA. rewrite fsetU0.
    rewrite fsetUid. rewrite fset_cons. rewrite <- fset0E. rewrite fsetUC. rewrite fsetUA.
    rewrite fsetUC. rewrite fsetUA.
    rewrite fsetUid. rewrite fsetUC.
    apply /eqP.
    reflexivity.
  Qed.
(*
  Lemma perf_ind_arit :
    ∀ {A B: choiceType} c0 c1 (pre : precond) (post : postcond A A) (a a0 x0 : Arit (uniform p)),
      ⊢ ⦃ pre ⦄ c0 (g ^+ x0) ≈ c1 (g ^+ x0) ⦃ post ⦄ →
      ⊢ ⦃ pre ⦄ c0 (g ^+ a0 ^+ a) ≈ c1 (g ^+ x0) ⦃ post ⦄.
 *)


  Search "^+".
  Search expgn_rec.

  (*
    fto : fin-to-option
    otf : option-to-fin
   *)

  Check (Finite.sort DDHP.Space).

  (* Understanding the types. *)
  (*
  Definition g    (a : Arit (uniform p)) : DDHP.Space := otf a.
  Definition g'   (a : DDHP.Space) : 'fin p := fto a.
  Definition g''  (a : 'fin p) : nat := ('I_p a * 'I_p a)%nat.
  Definition g''' (a : Arit (uniform p)) : nat := 'I_p (g' (g a)).
  *)
  (* I need the inverse function of g⁗.
     For that, I need to preserve [p].
   *)
  (*
  Definition g'''' (a : Arit (uniform p)) : 'fin (p * p) := ('I_p a * 'I_p a)%nat.
   *)
  (*
    I want to apply expgM!
   *)
  (*
  Definition f' (a : Arit (uniform p)) : Arit (uniform (p * p)) → Arit (uniform p) * nat :=
     fun x =>
      let '(b,c) := ch2prod x in
      let d := ((g''' a) * (g''' c))%nat in (* 'fin (a * c) *)
      (b,d).
   *)
  (* Search nat. Print divn. *)
  (*
  Definition h (a : Arit (uniform p)) : Arit (uniform p) * nat → Arit (uniform (p * p)) :=
                  fun x =>
                    let '(b,n) := x in
                    chProd (b, divn n a).
   *)
  Check Zp_mul.
  Definition k (a b : nat) : 'I_(a * b)%nat.+1 :=
    Zp_mul (inZp a) (inZp b).

  Search "Zp".
  Locate Zp_add.
  Print mathcomp.algebra.zmodp.
  Search "^+".
  Locate "^-".
  Check invg.
  Search invg.
  Locate "^+".
  Check expgn.
  Search (nat → baseFinGroupType).

  Check cyclePmin.
  Locate cyclePmin.
  Check proj1_sig.
  Check bijective.
  Print bijective.
  Locate "%:R".
  Check in_setT.

  (* ElGamal approach: *)
  Definition q : nat := #[g]. (* Cardinality of group g. *)
  Definition f''' (a : 'Z_q) : gT := g ^+ a.
  Definition g''' : forall (y:gT), (y \in <[g]>) -> 'Z_q :=
    fun y H =>
      let a' := proj1_sig(@cyclePmin gT g y H) in
      (a' %% q)%:R. (* We need the division [%%] in the the polynomial ring! *)

  (*
    Idea: Apply this [mulKn] or [mulnK].
   *)

  Definition coerc_arit_nat (a : Arit (uniform p)) : nat := a.

  Inductive SNat : nat -> Type :=
  | SNatc : forall n:nat, SNat n.

  Definition my_f {a b : nat} (ab: ((SNat a) * (SNat b))%type) : SNat (a * b)%N.
    destruct ab.
    exact (SNatc (muln a b)).
  Defined.

  Definition my_g {a b : nat} (c : SNat (a * b)%N) : ((SNat a) * (SNat b))%type := (SNatc a, SNatc b).

  Lemma bf : forall a b : nat, bijective (@my_f a b).
  Proof.
    intros.
    Check Bijective.
    Check my_f.
    Check my_g.
    apply (@Bijective (SNat (a * b)) (prod (SNat a) (SNat b)) my_f my_g).
    - unfold cancel. unfold my_f. unfold my_g. intros. destruct x. destruct s. destruct s0. reflexivity.
    - unfold cancel. unfold my_f. unfold my_g. intros. destruct x. reflexivity.
  Qed.


  (* Of course, this does not work. What are [a] and [b]?! *)
  Fail Definition my_f' (ab : nat * nat) : SNat (a * b)%N :=
    let '(a, b) := ab in
    my_f (SNatc a, SNatc b).


  (*
  (*
    To exploit this, we need a baseFinGroupType!
    Hence, we cannot work on the sampling space Z_p.
   *)
  Lemma inv : forall (x : gT) (y:nat), x = x ^+ y ^- y.
  Proof.
  Admitted.

*)
  Lemma my_mod : forall x y:nat, (x %% (x * y.+1).+1)%N = x.
  Proof.
    intros.
    Search ((?X %% ?Y)%N = ?X).
    rewrite modn_small.
    1: {reflexivity.}
      Search ((?X < ?Y.+1)%N).
    Search ((_ < _.+1)%N). rewrite ltnS. Search ((?X <= (?X * _) )%N). apply leq_pmulr. Search ((0 < _.+1)%N). apply ltn0Sn.
  Qed.

  Lemma my_mod' : forall x y:nat, (y %% (x.+1 * y).+1)%N = y.
  Proof.
    intros.
    rewrite mulnC.
    apply my_mod.
  Qed.

  Lemma my_mod'' : forall x y:nat, (x %% (x.+1 * y.+1).+1)%N = x.
  Proof.
    intros.
    Search ((?X %% ?Y)%N = ?X).
    rewrite modn_small.
    1: {reflexivity.}
      Search ((?X < ?Y.+1)%N).
    Search ((_ < _.+1)%N). rewrite ltnS.
    Search ((?X <= (?X + _) )%N).
    Search ((_.+1 * _ = _)%N). Search ((_ <= _ * _)%N).
    rewrite <- muln1 at 1.
    apply leq_mul.
    - apply leqnSn.
    - apply ltn0Sn.
  Qed.

  Lemma my_mul : forall (x y : nat)
                   (x' y'  : 'I_(x.+1*y.+1).+1),
      x' = inZp x →
      y' = inZp y →
      inZp (x * y) = x' *+ y'.
  Proof.
    intros.
    rewrite Zp_mulrn.
    f_equal.
    Search (inZp _).
    rewrite H H0.
    simpl.
    rewrite my_mod''. f_equal. rewrite mulnC. rewrite my_mod''. reflexivity.
  Qed.

  Check expgM.

  Search (_ ^+ ?X ^- ?X).

  Lemma Zp_mul_inv : forall (a b : 'Z_p),
      prime p ->
      b != 0 ->
      (Zp_mul (Zp_mul a b) (Zp_inv b)) = a.
  Proof.
    intros.
    
    rewrite Zp_mulC.
    assert (Zp_mul a b = Zp_mul b a). 1: { rewrite Zp_mulC. reflexivity.} rewrite H1. clear H1.
    rewrite Zp_mulA.
    rewrite Zp_mulVz.
    - rewrite Zp_mul1z. reflexivity.
    - assert ((1 < p)%N).
      1:{ apply prime_gt1. assumption. }.
      simpl.
      (*
        [rewrite (@Zp_cast p H0)]
        This fails with a cryptic type error because
         the rewrite is to greedy:
         https://stackoverflow.com/questions/43919377/coq-dependent-type-error-in-rewrite
       *)
      (*
        [rewrite (@Zp_cast p H0) at 1.]
        This fails because Coq requires a rewrite direction
        when using an occurence clause.
       *)
      (*
        [rewrite -> (@Zp_cast p H0) at 1.]
        This worked but it turned out that it is better not to do
        this rewrite because it allows me later on to apply [modZp].
       *)
      rewrite prime_coprime.
      + unfold dvdn.
        destruct p eqn:P.
        * discriminate.
        * simpl. rewrite modZp. assumption.
      + rewrite -> (@Zp_cast p H1) at 1. assumption.
  Qed.

  Locate "%/".
  Check divn.
  Search divn.

  (*
    Different approach: save it in the context instead of in the type!
   *)
  Definition my_f' (a : nat) (H : (0 < a)%N) : nat -> nat :=
    fun b => muln a b.

  Definition my_g' (a : nat) (H : (0 < a)%N) : nat -> nat :=
    fun c => divn c a.

  (* [H] is also not derivable because [p] is positive but not necessarily the
     number that was sampled from [p]. *)
  Lemma bij' : forall (a : nat) (H:(0 < a)%N), bijective (my_f' a H).
  Proof.
    intros.
    apply (@Bijective nat nat (my_f' a H) (my_g' a H)).
    - unfold cancel. unfold my_f'. unfold my_g'. intros.
      Search (((?X * ?Y) %/ ?X)%N). rewrite mulKn.
      1: { reflexivity. }
      assumption.
    - unfold cancel. unfold my_f'. unfold my_g'. intros.
      rewrite mulnC.
      Check divnK.
      Locate divn.
      rewrite divnK.
      1:{reflexivity.}
      Search ((_ %| _)%N). Locate "%|". Search dvdn. Print dvdn. unfold dvdn.
      Search ((_ %% _ = 0)%N).
      (*
        This does not work because the formula has the following form:
        [(x %/ m) * m].
        [%/] is the euclidean division.
        That is, I have to provide evidence that [x %| m == 0] or phrased
        differently: I have to show that there is no remainder in that division!
        And that I can not do.
       *)
  Abort.

(*
  Definition f (ab : Arit (uniform p) * Arit (uniform p)) : Arit (uniform p) :=
    let '(a, b) := ab in
    my_f (SNatc a, SNatc b).
 *)

  (*
  (*
    The below lemma is what we would need to prove.
   *)
  Lemma inv' : forall (x  y  xy  z: nat)
                 (x' y' xy'  : 'I_(x*y).+1), (* The inverse operation of multiplication needs to be on a group. *)
      xy = (x * y)%nat →  (* First direction: multiplication on natural numbers. *)
      x' = inZp x →
      y' = inZp y →     (* Second direction: division on natural numbers requires a detour via a group. *)
      xy' = inZp xy →
      z = (Zp_mul xy' (y' ^- 1)) →
      x = z.
  Proof.
    intros.
    rewrite H3 H2 H1.
    unfold Zp_mul.
    (*
      This feels to me like a very general lemma that should hold regardless
      of our special case here.
     *)
    Search inZp.
    rewrite <- Zp_mulrn.
    rewrite <- Zp_mulrn.
    rewrite Zp_expg.
    Search inZp.
    rewrite (valZpK (x*y)).
    rewrite <- Zp_mulrn.
    unfold "^-".
    unfold FinGroup.inv.
    simpl.
    Search "inv".
    Search "^+".
    Print mathcomp.algebra.zmodp.


    Lemma mul : forall (x y : nat) (x' y' xy'  : 'I_(x*y).+1),
        x' = inZp x →
        y' = inZp y →
        inZp (x' * y') = x * y.

  Definition f (a : Arit (uniform p)) : Arit (uniform (p * p)) → Arit (uniform p) * 'I_(a * p)%nat.+1 :=
     fun x =>
      let '(b,c) := ch2prod x in
      let d := (Zp_mul (inZp a) (inZp c)) in
      (b,d).
*)
(*
  Definition g (a : Arit (uniform p)) : Arit (uniform p) * 'I_(a * p)%nat.+1  → Arit (uniform (p * p)) :=
     fun x =>
      let '(b,d) := ch2prod x in
      let c := (Zp_mul (inZp a) (inZp c)) in
      fto (b,d).


  Lemma bijective_f : forall a, bijective (f a).
  Proof.
    intros.
    (* Search bijective. *)
    (* apply Bijective. *)
    Check bijective.
    Check Bijective.
    Check cancel.
    unfold f. simpl. unfold g'''. unfold g'. unfold g. simpl.
    admit.
    Admitted.
 *)

  Theorem DDH__security : ∀ L__A A,
      ValidPackage L__0 Game__Import Game__Export DH__real → (* 1st game pair package is valid *)
      ValidPackage L__1 Game__Import Game__Export DH__ideal → (* 2nd game pair package is valid *)
      ValidPackage L__A Game__Export A_export A → (* the valid attacker package *)
      fdisjoint L__A L__0 → (* the state of the attacker is disjoint to the state of 1st package of the game pair. *)
      fdisjoint L__A L__1 → (* the state of the attacker is disjoint to the state of 2nd package of the game pair. *)
      ɛ__DH A = 0. (* the attacker cannot distinguish between the two packages in the game. *)
  Proof.
    intros.
  (* Our goal now is to rewrite [epsilon__DH] with 0.
     The doc states:
     We need to prove a lemma of perfect indistinguishability of the two packages in the
     Game Pair.
   *)
    Check eq_rel_perf_ind_ignore.
    Check fsubset.
    eapply (eq_rel_perf_ind_ignore (fset [:: fk])). (* Invariant: heaps are subsets. *)
    - exact H.
    - exact H0.
    - apply ignored_is_subset.
    - simplify_eq_rel x.  (* [x] becomes the argument to the procedure. *)
      (* Check this state out in the editor!
         The proof actually reasons about the state via pre and post conditions.
         (Similar to Hoare logic.)
         Here, it is called a relational judgement.
       *)
      ssprove_code_simpl_more.
      (* The first two code steps are equal: *)
      ssprove_sync.
      intros.
      ssprove_sync.
      intros.
      (* This one now is more tricky.
         My strategy: I'm just going to delay dealing with the last sampling until the very end.
       *)
      ssprove_swap_rhs 0%N.
      ssprove_sync.
      ssprove_swap_rhs 0%N.
      ssprove_sync.
      (* Now, we have the differences between the two programs. *)
      (* I would like to get rid of the [get]s now.
         My strategy: I need to teach SSProve that [a = x0] and [a0 = x1].
         I want SSProve to remember that we wrote these values to the locations.
         This is only possible when I bring the code into a particular form where the
         [put] is followed immediately by a [get].
         I need to restart the proof.
       *)
      Restart.

    intros.
    eapply eq_rel_perf_ind_ignore.
    - exact H.
    - exact H0.
    - apply ignored_is_subset.
    - simplify_eq_rel x.
      ssprove_code_simpl_more.
      ssprove_sync. intros.
      ssprove_sync. intros.
      (* Remove the [get]s on the left-hand side. *)
      ssprove_swap_lhs 1%N. (* Now we have the proper form for [get] removal. *)
      ssprove_contract_put_get_lhs.
      ssprove_swap_rhs 0%N. (* Go away [sample]! *)
      ssprove_sync. (* 1st [put] gone. *)
      ssprove_contract_put_get_lhs. (* 2nd [get] gone. *)
      ssprove_swap_rhs 0%N. (* Go away [sample]! *)
      ssprove_sync. (* 2nd [put] gone. *)
      (* At this, we are left with the assertion (lhs) and the sampling (rhs). *)
      (*
        - There are rules still missing in SSProve. It would have helped to have
          a lemma that just kicks out assertions that are not used anywhere.
          I had to introduce the same assertion into the ideal version to make further progress.
        - I also had to store the final key into the state in the real version.
          The key lesson learned here is, if the states are different then we need to
          use the other invariant. But we cannot just use the same state and not use
          one of the state slots in one of the version. The problem that
          we are facing is that we cannot drop a lonely [put].
       *)
      eapply r_const_sample_R.
      + (* Search "LosslessOp". *) apply LosslessOp_uniform.
      + intros. eapply r_put_rhs.

        (* Careful here!
           It seems like a good idea to remove the [ret].
           But that also is the last command and will drop us
           from [≈] (perfect indistinguishability) into [=] (equality).

           Check out the steps below.
           We end up having to prove [(a0 * a)%N = x0] which is
           exactly the difference in the two programs.
           But this lemma cannot be proven!
           What we actually want to prove is [(a0 * a)%N ≈ x0].
           We want to state that these two sides are indistinguishable!

        eapply r_ret.
        intros. split.
        * apply f_equal. apply f_equal. apply f_equal.
          (* At this point, I'm basically at the core of the proof.
             I have to prove [g ^+ a0 ^+ a = g ^+ x0].
           *)
          (* Search "^+". *)
          rewrite <- expgM. apply f_equal.
          (* Reduced to a proof for [(a0 * a)%N = x0]. *)
          destruct x0. destruct a0. destruct a. simpl.
        * Search set_rhs. unfold set_rhs in H4. Search set_heap. inversion H4. destruct H5.
        *)

        (* Our goal is to finish off with [r_reflexivity], in fact
           stating that the computations on both sides are indistinguishable
           from each other for an attacker.
         *)
        eapply r_ret. intros. split.
        * repeat f_equal. Search "^+". 1: { rewrite <- expg1. f_equal. destruct a0. cbn. inversion i. admit.  } admit.
        * admit.
    - ssprove_valid.
    - auto.
    - auto.

      Restart.

    intros.
    eapply eq_rel_perf_ind_ignore.
    - exact H.
    - exact H0.
    - apply ignored_is_subset.
    - simplify_eq_rel x.
      ssprove_code_simpl_more.
      ssprove_sync. intros.

      (* Take care of the put/get combos. *)
      ssprove_swap_lhs 0%N.
      ssprove_swap_lhs 2%N.
      ssprove_swap_lhs 1%N.
      ssprove_contract_put_get_lhs.
      ssprove_swap_rhs 1%N.
      ssprove_swap_rhs 0%N.
      ssprove_sync.

      (* This pattern is only here to turn two distinct samples
         on the right-hand side into a single one.
       *)
      eapply r_transR.
      Check r_uniform_prod.
      1: { eapply r_uniform_prod. intros. eapply rreflexivity_rule. }

      simpl.

      (* Now we need to define a function that says, how we get from one variable on the
       left-hand side to a different (but by sampling connected) variable
       on the right-hand side. *)
      (* eapply rsymmetry. *)
      Check r_uniform_bij.
      Locate r_uniform_bij.
      eapply r_uniform_bij.
      Search (_ ^+ _ ^+ _).
      Search (_ ^- _).
      (*
        g ^+ n ^+ m = g ^+ (n * m)
        x1 := x0
        n := x1
        m := a

        y := x1 * a
        y := (fun x0: x0 * a) x0

        Zp :
        f a := (fun x0 : x0 * a)
        inv_f a := (fun y : y * a-1)

        f a := (fun x0 : get_exp (g ^+ x0 ^+ a))
        inv_f := (fun y: get_exp (g ^+ y ^- a) )

      Definition f (a : Arit (uniform p)) : forall x:Arit (uniform p), (Arit (uniform p)) * 'I_(x ^+ a)
      Definition f_inv (a : Arit (uniform p)) : (Arit (uniform p)) * nat → Arit (uniform p)

      (*
        I may be on the wrong track here because
        Z_p * Z_p does not mean that I enter into Z_p again.
        But that is not a problem in fact.
        I can have :
        [Definition f : Z_{p}_{} → Z_{p}_{}_{} → Z_{p*p}]
        and the inverse operation:
        [Definition g : Z____{}_{p*p} → Z_{p}×Z_{p}_{}_{}]
        Or more general:
        [Definition f : Z___{i} → Z_{j}_{} → Z_{i*j}]
        and the inverse operation:
        [Definition g : Z_{i*j} → Z_{i}×Z_{j}_{}_{}]
       *)
      Check expgM.
      (*
      f (x1, a) = y
      g y = (x1, a)
       *)

      ssprove_sync. intros.
      (* Remove the [get]s on the left-hand side. *)



    - ssprove_valid.
    - auto.
    - auto.

  Admitted.


End SigmaProtocol.

