(** *Introduction

In order to get into SSProve, it makes sense to look at a "simple" protocol
implementation and its verification.
I took this file straight from 'ssprove/theories/Crypt/examples/SigmaProtocol.v' and copied it here such
that I/we can add comments that will help us to understand.
*)
From Relational Require Import OrderEnrichedCategory GenericRulesSimple.

Set Warnings "-notation-overridden,-ambiguous-paths".
From mathcomp Require Import all_ssreflect all_algebra reals distr realsum
  fingroup.fingroup solvable.cyclic prime ssrnat ssreflect ssrfun ssrbool ssrnum
  eqtype choice seq.
Set Warnings "notation-overridden,ambiguous-paths".


From Crypt Require Import Axioms ChoiceAsOrd SubDistr Couplings
  UniformDistrLemmas FreeProbProg Theta_dens RulesStateProb UniformStateProb
  pkg_core_definition choice_type pkg_composition pkg_rhl
  Package Prelude RandomOracle.

From Coq Require Import Utf8.
From extructures Require Import ord fset fmap.
Require Import Lia.

From Equations Require Import Equations.
Require Equations.Prop.DepElim.

Set Equations With UIP.

Set Bullet Behavior "Strict Subproofs".
Set Default Goal Selector "!".
Set Primitive Projections.
Set Printing Coercions.

Import Num.Def.
Import Num.Theory.
Import Order.POrderTheory.

Import PackageNotation.

#[local] Open Scope ring_scope.
Import GroupScope GRing.Theory.

(** Simple scheme: Diffie Hellmann Key Exchange

The scheme: A, B agree on prime p and element g \in group G = Z_p

    A:                          B:
sample a from G
A = g^a          ----A --->
                             sample b from G
                             B = g^b
                <----B-----
k=B^a                        k'=A^b

Lemma: k = k'
**)

(*
Locate ">".
Print cycle_group. (* Has Notation <[ g ]> *)

Locate "#[".
Print order.
Search (#[_]).
 *)

Module Type DHParams.

  (* Read:
https://math-comp.github.io/htmldoc/mathcomp.fingroup.fingroup.html
   *)
  Parameter gT : finGroupType.            (* We need a group type of finite size. *)
  Definition ζ : {set gT} := [set : gT].  (* The group needs to be a set. *)
  Parameter g :  gT.                      (* This is the group element [g]. *)
  Parameter g_gen : ζ = <[g]>.            (* Predicate: The group [ζ] is equal to the cyclic subgroup generated by [g]. *)
  Parameter prime_order : prime #[g].     (* Property: The order of the cyclic subgroup generated from [g] is a prime number. *)
  (* Parameter prime_order : prime #|gT|.*)     (* Property: The order of the group [gT]. *)
  (* Check this fact:
     gauss : prime g -> #[gt] = #|gT|
   *)

End DHParams.


Module Type DHAux (DHP : DHParams).

  Import DHP.

  #[local] Open Scope package_scope.

  (* We need to prove that #|GroupSpace| is positive. *)
  Definition GroupSpace : finType := FinGroup.arg_finType gT.
  #[local] Instance GroupSpace_pos : Positive #|GroupSpace|.
  Proof.
    apply /card_gt0P; by exists g.
  (* Needs to be transparent to unify with local positivity proof? *)
  Defined.

  Definition chGroup : choice_type := 'fin #|GroupSpace|.
  Notation " 'group " := (chGroup) (in custom pack_type at level 2).

  (* [p] itself is derived from the DiffieHellmann Parameters. *)
  Definition p := #[g].
(*    Definition p := #|gT|. *)

  Lemma p_gt1 : (1 < p)%N.
  Proof.
    apply (prime_gt1 prime_order).
  Qed.

  #[export] Instance p_pos : Positive p.
  Proof.
    rewrite /p/Positive.
    move: p_gt1; rewrite /p //=.
  Defined.
  Definition chPElem : choice_type := 'fin p.

End DHAux.


Module Type Conversions (DHP : DHParams) (DHA : DHAux DHP).

  Import DHA.

  (* otf *)
  (*
  Definition intoZp' : Arit (uniform p) -> 'I_#|Arit (uniform p)|. (* 'Z_p.*)
  Proof.
    move => x.
    apply enum_rank.
    exact x.
  Defined.
   *)
  Definition intoZp' : Arit (uniform p) -> 'I_#|Arit (uniform p)| := enum_rank.

  (*
    The point here is essentially that Z_p means that [p > 1].
    This is stated in the definition of Z_p here: https://math-comp.github.io/htmldoc_1_16_0/mathcomp.algebra.zmodp.html
    So have to use the [prime_gt1 prime_order] fact in this construction.
   *)
  Definition intoZp'' : 'I_#|Arit (uniform p)| -> 'Z_p := inZp.


  Print inZp.

  Fail Definition intoZp''' : 'I_p -> 'Z_p := enum_val.

  Definition _intoZp : Arit (uniform p) -> 'Z_p :=
    fun x => intoZp'' (intoZp' x).

  (* fto *)
  Definition fromZp' : 'I_#|Arit (uniform p)| -> Arit (uniform p).
  Proof.
    move => x.
    eapply enum_val.
    (* Unshelve. *)
    exact x.
  Defined.
  Print fromZp'.

  Definition fromZp''' : 'I_#|Arit (uniform p)| -> Arit (uniform p) := [eta enum_val].
  Definition fromZp'''' : 'I_#|Arit (uniform p)| -> Arit (uniform p) := enum_val.

  Definition fromZp'' : 'Z_p -> 'I_#|Arit (uniform p)|.
  Proof.
    move => x.
    case: x => m.
    rewrite (Zp_cast p_gt1) card_ord => m_lt_p. (* rewriting inside definitions is painful later on. *)
    exact (Ordinal m_lt_p).
  Defined.

  Definition fromZp''''' : 'Z_p -> 'I_#|Arit (uniform p)|.
  Proof.
    move => x.
    case: x => m.
    rewrite (Zp_cast p_gt1) card_ord => m_lt_p. (* rewriting inside definitions is painful later on. *)
    exact (Ordinal m_lt_p).
  Defined.


  Definition _fromZp : 'Z_p -> Arit (uniform p) := fun x => fromZp' (fromZp'' x).

  Lemma intoZp'_fromZp' : forall (x : Arit (uniform p)),
      fromZp' (intoZp' x) = x.
  Proof.
    rewrite /intoZp'/fromZp' => x.
    apply enum_rankK.
  Qed.

  Lemma fromZp'_intoZp' : forall (x : 'I_#|Arit (uniform p)|),
      intoZp' (fromZp' x) = x.
  Proof.
    rewrite /intoZp'/fromZp' => x.
    apply enum_valK.
  Qed.

  Lemma intoZp''_fromZp'' : forall (x : 'I_#|Arit (uniform p)|),
      fromZp'' (intoZp'' x) = x.
  Proof.
    rewrite /intoZp''/fromZp'' => x //=.
    rewrite /eq_rect_r/eq_rect //=.
  Abort.

  Definition intoZ : Arit (uniform p) -> 'Z_p := inZp.

  Definition intoZ' : Arit (uniform p) -> 'Z_p.
  Proof.
    move => x.
    Check @enum_rank.
    Check 'I_p.
    Print predArgType.
    Print finType.
    Check (enum_rank (T:=Zp_finZmodType p)).
    Print intoZp'.
    Fail apply (enum_rank (T:=Zp_finZmodType p)).
  Abort.

  Definition fromZ : 'Z_p -> Arit (uniform p).
  Proof.
    move => x.
    apply (enum_val (A:='I_p)).
    rewrite card_ord.
    move: x; rewrite (Zp_cast p_gt1) //=.
  Defined.

  Lemma intoZ_fromZ : forall x: Arit (uniform p), fromZ (intoZ x) = x.
  Proof.
    move => x.
    rewrite /intoZ.
    Check (inZp (nat_of_ord x)).
    Check @valZpK.
    Fail rewrite (@valZpK p.-1 x).
    Fail rewrite (inZp (nat_of_ord x)).
  Abort.


  (* Restart with new definitions. *)

  Definition into {q:nat} : (1 < q)%N -> 'I_q -> 'I_q.-2.+2 :=
    match q with
    | _.+2 => fun _ => id
    | _ => fun H => False_rect _ (Bool.diff_false_true H)
    end.

  Definition from {q:nat} : (1 < q)%N -> 'I_q.-2.+2 -> 'I_q :=
    match q with
    | _.+2 => fun _ => id
    | _ => fun H => False_rect _ (Bool.diff_false_true H)
    end.

  Lemma into_from {q:nat} (H : (1 < q)%N) x : from H (into H x) = x.
  Proof. by case: q H x => [|[]]. Qed.

  Lemma from_into {q:nat} (H : (1 < q)%N) x : into H (from H x) = x.
  Proof. by case: q H x => [|[]]. Qed.

  Lemma conv_Ip_bij {q:nat} (q_gt1 : (1 < q)%N) :
    bijective (into q_gt1).
  Proof.
    exact
      (Bijective
         (into_from q_gt1)
         (from_into q_gt1)).
  Qed.

  Definition Ip_into_Zp {q:nat} : 'I_q.-2.+2 -> 'Z_q := id.
  Definition Zp_into_Ip {q:nat} : 'Z_q -> 'I_q.-2.+2 := id.

  Lemma Ip_into_Zp_l {q:nat} :
    forall (x: 'I_q.-2.+2), Zp_into_Ip (Ip_into_Zp x) = x.
  Proof. by []. Qed.

  Lemma Zp_into_Ip_l {q:nat} :
    forall (x: 'Z_q), Ip_into_Zp (Zp_into_Ip x) = x.
  Proof. by []. Qed.

  Definition intoZp {q:nat} (q_gt1 :(1 < q)%N) : 'I_q -> 'Z_q :=
    fun x => Ip_into_Zp (into q_gt1 x).

  Definition fromZp {q:nat} (q_gt1 :(1 < q)%N) : 'Z_q -> 'I_q :=
    fun x => from q_gt1 (Zp_into_Ip x).

  Lemma intoZp_fromZp {q:nat} (q_gt1 :(1 < q)%N) :
    forall x, fromZp q_gt1 (intoZp q_gt1 x) = x.
  Proof.
    by case: q q_gt1 => [|[]].
  Qed.

  Lemma fromZp_intoZp {q:nat} (q_gt1 :(1 < q)%N) :
    forall x, intoZp q_gt1 (fromZp q_gt1 x) = x.
  Proof.
    by case: q q_gt1 => [|[]].
  Qed.

  Lemma conv_Zp_bij {q:nat} (q_gt1 : (1 < q)%N) :
    bijective (intoZp q_gt1).
  Proof.
    exact
      (Bijective
         (intoZp_fromZp q_gt1)
         (fromZp_intoZp q_gt1)).
  Qed.

  Definition Arit_Zp {gT: finGroupType} (q_gt1 : (1 < #|gT|)%N) : Arit (uniform #|gT|) -> 'Z_#|gT| :=
    fun x => intoZp q_gt1 x.

  Definition Zp_Arit {gT: finGroupType} (q_gt1 : (1 < #|gT|)%N) : 'Z_#|gT|  -> Arit (uniform #|gT|) :=
    fun x => fromZp q_gt1 x.

  Definition Arit_Zp' {gT: finGroupType} {g: gT} (q_gt1 : (1 < #[g])%N) : Arit (uniform #[g]) -> 'Z_#[g] :=
    fun x => intoZp q_gt1 x.

  Definition Zp_Arit' {gT: finGroupType} {g: gT} (q_gt1 : (1 < #[g])%N) : 'Z_#[g]  -> Arit (uniform #[g]) :=
    fun x => fromZp q_gt1 x.

  (* Specific for the DH setup: *)
  Definition Aritp_Zp : Arit (uniform p) -> 'Z_p := Arit_Zp' p_gt1.
  Definition Zp_Aritp : 'Z_p -> Arit (uniform p) := Zp_Arit' p_gt1.
End Conversions.


Module DiffieHellman
  (DHP : DHParams)
  (DHAux : DHAux DHP)
  (C : Conversions DHP DHAux).

  Import DHP.
  Import DHAux.
  Import C.

  (* This is a trick to give names to functions. *)
  Definition DDH : nat := 0.

  (* I want to store some elements of the group in the state. *)
  Definition sk_A : Location := (chPElem ; 0%N).
  Definition sk_B : Location := (chPElem ; 1%N).
  Definition fk : Location := (chPElem ; 2%N).

  (* Definition L__0 := fset [:: sk_A ; sk_B ; fk]. *)
  (* Using [L__0 ≔ fset[:: sk_A ; sk_B] ] here will make the proof more complicated because then
     we need to use another invariant over the heap. *)
  Definition L__0 := fset [:: sk_A ; sk_B].
  Definition L__1 := L__0 :|: fset [:: fk].

  #[local] Open Scope package_scope.

  Print fto.

  (* We need these definitions multiple times below.
     So just define them once here.
     Note that a game package needs to export a procedure of type ['unit → t] where [t] is some choice type.
   *)
  Definition Game__Import : Interface := [interface].
  Definition Game__Export : Interface := [interface #val #[ DDH ] : 'unit → 'group × 'group × 'group].

  Definition DH__real:
    package L__0
      Game__Import Game__Export
  :=
  [package
    #def #[ DDH ] (_ : 'unit) : 'group × 'group × 'group
    {
      (* Initially the state locations are empty. Let's fill them: *)
      sk_alice ← sample uniform p ;;
      #assert (0 != Aritp_Zp sk_alice) ;; (* I do not know how to get this information from the sampling. *)
      sk_bob ← sample uniform p ;;
      #assert (0 != Aritp_Zp sk_bob) ;;
      #put sk_A := sk_alice ;;
      #put sk_B := sk_bob ;;

      (* Now, let's start with the protocol. *)

      (* Alice side: ephemeral key gen *)
      sk_alice' ← get sk_A ;;
      let e_a := (g^+ sk_alice') in

      (* Bob side: ephemeral key gen *)
      sk_bob' ← get sk_B ;;
      let e_b := (g^+ sk_bob') in

      (*
        If we want to model this properly then we would also have a state
        for the communication between Alice and Bob.
        Right now, the [Send_EphKey] function does not make much sense.
        It is essentially just [id].
       *)
      (*
      e_a_at_bob ← Send_EphKey e_a ;;
      e_b_at_alice ← Send_EphKey e_b ;;
       *)
      let e_a_at_bob := e_a in
      let e_b_at_alice := e_b in

      (* Alice side: final key gen *)
      let fk_alice := (e_b_at_alice^+ sk_alice') in

      (* Bob side: final key gen *)
      let fk_bob := (e_a_at_bob^+ sk_bob') in

      (* To reason about the correctness of the protocol/program
         just use assertions (of type [bool] not [Prop]!):
       *)
      (*
      [assert (fk_alice == fk_bob) ;;]
      Lesson learned: Don't define assertions that you do not use later on the code.
      The "ideal" package will need to define those too.
       *)

      (* Lesson learned:
         If the states look the same then I have to treat them in the same way.
         It is currently not possible to remove "lonely" [put] calls.

         I cannot put [fk_alice] blindly because obviously the type is not the
         same as for yet another value sampled from the distribution.
         [#put fk := fk_alice ;;]
       *)

      (* Our output here is essentially our communication, i.e.,
         everything that the attacker should be able to see but hopefully
         not be able to recover.
       *)
      ret (fto e_a , (fto e_b, fto fk_alice))
    }
  ].

  (** *** Simulated implementation
      Here, we really remove all the noise and just perform the mathematic
      operations.
   *)

  Lemma sk_A_in_L__1: sk_A \in L__1.
  Proof.
    unfold L__1. unfold L__0. (* Search "in_fset". *)
    rewrite in_fsetU. (* Locate "||". Print orb. Search "fset". *)
    apply /orP. left.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite in_fset1.
    apply /eqP.
    reflexivity.
  Qed.

  Lemma sk_B_in_L__1: sk_B \in L__1.
  Proof.
    unfold L__1. unfold L__0.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. right.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite in_fset1.
    apply /eqP.
    reflexivity.
  Qed.

  Lemma fk_in_L__1: fk \in L__1.
  Proof.
    unfold L__1. unfold L__0.
    rewrite in_fsetU.
    apply /orP. right.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite in_fset1.
    apply /eqP.
    reflexivity.
  Qed.


  Definition DH__ideal: package L__1 Game__Import Game__Export.
    refine(
        [package
           #def #[ DDH ] (_ : 'unit) : 'group × 'group × 'group
           {
             a ← sample uniform p ;;
             #assert (0 != Aritp_Zp a) ;;
             b ← sample uniform p ;;
             #assert (0 != Aritp_Zp b) ;;
             c ← sample uniform p ;;

             #put sk_A := a ;;
             #put sk_B := b ;;
             (* This was interesting:
                When not putting [c] into the state, I received a cryptic error message.
                It seems everything that was sampled needs to go into the state otherwise
                the package is not valid.
              *)
             #put fk := c ;;

             (* We are saying the an attacker would not be able to differentiate between
                our computed result and a randomly chosen one. *)
             ret (fto (g^+ a), (fto (g^+ b), fto (g^+ c)))
         }
      ]).
     ssprove_valid.
    - apply sk_A_in_L__1.
    - apply sk_B_in_L__1.
    - apply fk_in_L__1 .
  Defined.

  (* There is also a way to package a defined ValidCode into a ValidPackage.
     This does not work in the above case because the return type differ.
   *)
  Equations ddh_ideal : code L__1 [interface]
                     (prod_choiceType
                        (prod_choiceType
                           (FinGroup.choiceType gT)
                           (FinGroup.choiceType gT))
                        (FinGroup.choiceType gT)) :=
  ddh_ideal := {code
           a ← sample uniform p ;;
           b ← sample uniform p ;;
           c ← sample uniform p ;;

           #put sk_A := a ;;
           #put sk_B := b ;;
           #put fk := c ;;

           ret ((g^+ a), (g^+ b), (g^+ c))
      }.
  Next Obligation.
    ssprove_valid.
    - apply sk_A_in_L__1.
    - apply sk_B_in_L__1.
    - apply fk_in_L__1 .
  Defined.

  (* It is also possible to extend the ssprove_valid db
     with hints for the lemmas.
     [Hint Extern ... : typeclass instance ssprove_valid]
   *)


  (*
    Now, I can define an advantage, i.e., a game.
    An attacker (package) [A] can not distinguish between the two (package) versions.
   *)
  Definition ɛ__DH A := AdvantageE DH__real DH__ideal A.

  (* The exported interface for running the game via the attacker package is
     predefined for us in SSProve.
   *)
  Check A_export.

  Lemma ignored_is_subset : fsubset (fset [:: fk]) (L__0 :|: L__1).
  Proof.
    unfold fsubset. rewrite fset_cons. unfold L__1. rewrite <- fset0E. rewrite fsetUC.
    rewrite fsetUA. rewrite fset_cons. rewrite <- fset0E. rewrite fsetU0.
    rewrite fsetUA. rewrite fset1E. rewrite fsetUA. rewrite fsetU0.
    rewrite fsetUid. rewrite fset_cons. rewrite <- fset0E. rewrite fsetUC. rewrite fsetUA.
    rewrite fsetUC. rewrite fsetUA.
    rewrite fsetUid. rewrite fsetUC.
    apply /eqP.
    reflexivity.
  Qed.
(*
  Lemma perf_ind_arit :
    ∀ {A B: choiceType} c0 c1 (pre : precond) (post : postcond A A) (a a0 x0 : Arit (uniform p)),
      ⊢ ⦃ pre ⦄ c0 (g ^+ x0) ≈ c1 (g ^+ x0) ⦃ post ⦄ →
      ⊢ ⦃ pre ⦄ c0 (g ^+ a0 ^+ a) ≈ c1 (g ^+ x0) ⦃ post ⦄.
 *)


  (*
    fto : fin-to-option
    otf : option-to-fin
   *)

  (* Understanding the types. *)
  (*
  Definition g    (a : Arit (uniform p)) : DDHP.Space := otf a.
  Definition g'   (a : DDHP.Space) : 'fin p := fto a.
  Definition g''  (a : 'fin p) : nat := ('I_p a * 'I_p a)%nat.
  Definition g''' (a : Arit (uniform p)) : nat := 'I_p (g' (g a)).
  *)
  (* I need the inverse function of g⁗.
     For that, I need to preserve [p].
   *)
  (*
  Definition g'''' (a : Arit (uniform p)) : 'fin (p * p) := ('I_p a * 'I_p a)%nat.
   *)
  (*
    I want to apply expgM!
   *)
  (*
  Definition f' (a : Arit (uniform p)) : Arit (uniform (p * p)) → Arit (uniform p) * nat :=
     fun x =>
      let '(b,c) := ch2prod x in
      let d := ((g''' a) * (g''' c))%nat in (* 'fin (a * c) *)
      (b,d).
   *)
  (* Search nat. Print divn. *)
  (*
  Definition h (a : Arit (uniform p)) : Arit (uniform p) * nat → Arit (uniform (p * p)) :=
                  fun x =>
                    let '(b,n) := x in
                    chProd (b, divn n a).
   *)
  Check Zp_mul.
  Definition k (a b : nat) : 'I_(a * b)%nat.+1 :=
    Zp_mul (inZp a) (inZp b).

  (* ElGamal approach: *)
  Definition q : nat := #[g]. (* Cardinality of group g. *)
  Definition f''' (a : 'Z_q) : gT := g ^+ a.
  Definition g''' : forall (y:gT), (y \in <[g]>) -> 'Z_q :=
    fun y H =>
      let a' := proj1_sig(@cyclePmin gT g y H) in
      (a' %% q)%:R. (* We need the division [%%] in the polynomial ring! *)

  (*
    Idea: Apply this [mulKn] or [mulnK].
   *)

  Definition coerc_arit_nat (a : Arit (uniform p)) : nat := a.

  Inductive SNat : nat -> Type :=
  | SNatc : forall n:nat, SNat n.

  Definition my_f {a b : nat} (ab: ((SNat a) * (SNat b))%type) : SNat (a * b)%N.
    destruct ab.
    exact (SNatc (muln a b)).
  Defined.

  Definition my_g {a b : nat} (c : SNat (a * b)%N) : ((SNat a) * (SNat b))%type := (SNatc a, SNatc b).

  Lemma bf : forall a b : nat, bijective (@my_f a b).
  Proof.
    intros.
    Check Bijective.
    Check my_f.
    Check my_g.
    apply (@Bijective (SNat (a * b)) (prod (SNat a) (SNat b)) my_f my_g).
    - unfold cancel. unfold my_f. unfold my_g. intros. destruct x. destruct s. destruct s0. reflexivity.
    - unfold cancel. unfold my_f. unfold my_g. intros. destruct x. reflexivity.
  Qed.


  (* Of course, this does not work. What are [a] and [b]?! *)
  Fail Definition my_f' (ab : nat * nat) : SNat (a * b)%N :=
    let '(a, b) := ab in
    my_f (SNatc a, SNatc b).


  (*
  (*
    To exploit this, we need a baseFinGroupType!
    Hence, we cannot work on the sampling space Z_p.
   *)
  Lemma inv : forall (x : gT) (y:nat), x = x ^+ y ^- y.
  Proof.
  Admitted.

*)
  Lemma my_mod : forall x y:nat, (x %% (x * y.+1).+1)%N = x.
  Proof.
    intros.
    (* Search ((?X %% ?Y)%N = ?X). *)
    rewrite modn_small.
    1: {reflexivity.}
      (* Search ((?X < ?Y.+1)%N). *)
      (* Search ((_ < _.+1)%N). *)
      rewrite ltnS.
    (* Search ((?X <= (?X * _) )%N). *)
    apply leq_pmulr.
    (* Search ((0 < _.+1)%N). *)
    apply ltn0Sn.
  Qed.

  Lemma my_mod' : forall x y:nat, (y %% (x.+1 * y).+1)%N = y.
  Proof.
    intros.
    rewrite mulnC.
    apply my_mod.
  Qed.

  Lemma my_mod'' : forall x y:nat, (x %% (x.+1 * y.+1).+1)%N = x.
  Proof.
    intros.
    (* Search ((?X %% ?Y)%N = ?X). *)
    rewrite modn_small.
    1: {reflexivity.}
    (*  Search ((?X < ?Y.+1)%N).
    Search ((_ < _.+1)%N). *)
    rewrite ltnS.
    (* Search ((?X <= (?X + _) )%N).
    Search ((_.+1 * _ = _)%N). Search ((_ <= _ * _)%N). *)
    rewrite <- muln1 at 1.
    apply leq_mul.
    - apply leqnSn.
    - apply ltn0Sn.
  Qed.

  Lemma my_mul : forall (x y : nat)
                   (x' y'  : 'I_(x.+1*y.+1).+1),
      x' = inZp x →
      y' = inZp y →
      inZp (x * y) = x' *+ y'.
  Proof.
    intros.
    rewrite Zp_mulrn.
    f_equal.
    (* Search (inZp _). *)
    rewrite H H0.
    simpl.
    rewrite my_mod''. f_equal. rewrite mulnC. rewrite my_mod''. reflexivity.
  Qed.

  Check expgM.

  Section Zp_bij.

    Variable q:nat.

    Lemma mul_inv : forall (a b : 'Z_q),
      prime q ->
      b != 0 ->
      (Zp_mul (Zp_mul a b) (Zp_inv b)) = a.
    Proof.
      intros.

      rewrite Zp_mulC.
      assert (Zp_mul a b = Zp_mul b a). 1: { rewrite Zp_mulC. reflexivity.} rewrite H1. clear H1.
      rewrite Zp_mulA.
      rewrite Zp_mulVz.
      - rewrite Zp_mul1z. reflexivity.
      - assert ((1 < q)%N).
        1:{ apply prime_gt1. assumption. }.
        simpl.
        (*
        [rewrite (@Zp_cast p H0)]
         This fails with a cryptic type error because
         the rewrite is too greedy:
         https://stackoverflow.com/questions/43919377/coq-dependent-type-error-in-rewrite
         *)
        (*
        [rewrite (@Zp_cast p H0) at 1.]
        This fails because Coq requires a rewrite direction
        when using an occurence clause.
        (In fact, the above rewrite is the one from SSReflect. Giving a a direction switches back to
        the basic rewrite tactic.)
         *)
        (*
        [rewrite -> (@Zp_cast p H0) at 1.]
        This worked but it turned out that it is better not to do
        this rewrite because it allows me later on to apply [modZp].
         *)
        rewrite prime_coprime.
        + unfold dvdn.
          destruct q eqn:Q.
          * discriminate.
          * simpl. rewrite modZp. assumption.
        + rewrite -> (@Zp_cast q H1) at 1. assumption.
    Qed.

    (*
      TODO: Define the function [f] that pattern matches on
      [a]. In case of [0] we just map to [0] otherwise we use
      [Zp_mul] with the [Zp_inv] under the condition that [a > 0].
     *)
    Definition f (H : prime q) (a : 'Z_q) : 'Z_q -> 'Z_q :=
      fun b =>
        (*
        match b with
        | Ordinal 0 _ => Zp0
        | Ordinal (S _) _ => Zp_mul a b
        end. *)
        if b == Zp0 then Zp0 else Zp_mul b a.

    Definition f_inv (H : prime q) (a : 'Z_q) : 'Z_q -> 'Z_q :=
      fun c =>
        (* match c with
        | Ordinal 0 _ => Zp0
        | Ordinal (S _) _ => Zp_mul c (Zp_inv a)
        end. *)
        if c == Zp0  then Zp0 else Zp_mul c (Zp_inv a).

    Lemma f_inj : forall (H : prime q) (a : 'Z_q) (Ha : (0 < a)%N),
        cancel (f H a) (f_inv H a).
    Proof.
      move => prime_q a O_lt_a.
      rewrite /cancel/f/f_inv /=.
      case => m. case En: m => [|n].
      - move => /=.
        (* The way via [nat] works too:
           [move=> lt0; apply: val_inj => //=.]
           as proposed in Zulip.
         *)
        rewrite /Zp0 /ord0 => i; f_equal => //=; apply/bool_irrelevance.
      -  move => i //=.
         have lt0 : forall x y :nat, x = y.+1 -> (0 < x)%N.
         1:{  by [elim]. }
         move: En; move/(lt0 m n) => O_lt_m //=.
         (*
           If [a=Zp0] then this is not the case.
           I thought that I can map [a=0 /\ b=n -> Zp0].
           But the truth is that [a=n.+1 /\ b=0 -> Zp0] too.
           Hence, the function is not injective!
          *)
         rewrite {1}/Zp_mul //=.
         case Ea: (nat_of_ord a) => [|mn].
         + move: O_lt_a; rewrite Ea => O_lt_a //=.
         +
           have mulnSSgt0 : forall x y z: nat, (x.+1 * y.+1)%N = z -> (0 < z)%N.
           1:{
             move => x y z; case: x; case: y => //=.
             - cbn. move => zeq1; rewrite -zeq1 => //=.
             - move => n0 //=; rewrite mul1n => zeq2; rewrite -zeq2 //=.
             - move => n0 //=; rewrite muln1 => zeq2; rewrite -zeq2 //=.
             - move => n0 n1 zeq //=; rewrite -zeq //=.
           }

           have q_gt1 : (1 < q)%N.
           1:{ apply (prime_gt1 prime_q). }

           have Zp1neqInZp0 : is_true (@Zp1 q != @inZp q 0).
           1:{
             apply: contra (Zp_nontrivial q).
             rewrite /Zp1. move/eqP. f_equal.
             rewrite /inZp.
             (* move/eqP => /=. *)
             move/eqP.
             Check (inj_eq val_inj). (* [val_inj] is an argument to [inj_eq]! *)
             rewrite -(inj_eq val_inj) //=.
             case Eq: q => [|nq] //-.
             nat_reify.
             move: q_gt1; rewrite Eq => one_lt0 //=. inversion one_lt0.
           }

           have Zp1neqInZp0' : forall p:nat, (1 < p)%N -> is_true (@Zp1 p != @inZp p 0).
           1:{ clear. by case. }

           have Zp1neqInZp0'' : forall p:nat, (1 < p)%N -> is_true (@Zp1 p != @inZp p 0).
           1:{ clear. case => //=. }

           have Zp1neqInZp0''' : forall p:nat, (1 < p)%N -> is_true (@Zp1 p != @inZp p 0).
           1:{
             clear. case.
             - move => //=.
             - move => //=.
           }

           have Zp1neqZp0 : is_true (@Zp1 q != @Zp0 q).
           1:{
             apply: contra (Zp_nontrivial q).
             case Eq : q => TT //=. move:q_gt1; rewrite Eq => one_lt0 //=.
           }

           have mulnSSgtZp0 : forall x y: nat, @inZp q (x.+1 * y.+1)%N != @Zp0 q.
           1:{
             case => [|x0]; case => [|y0] //=.
             - move => //=. rewrite mul1n -/Zp1 => //=.

               (*
                 Helper tactic in SSProve to convert boolean (in)equalities into propositional ones.
                 Works on all hypotheses but not on the goal.
                 Uses SSReflect view lemmas.
                *)
               (* nat_reify. *)
               apply: contra (Zp_nontrivial q).
               1:{ rewrite -(inj_eq val_inj) //=.
                   nat_reify.
                   move:q_gt1 => //=.
                   elim: q => [|nq IHn] //=.
                   - move => one_lt0 //=. inversion one_lt0.
                   - move => SSeq0 //=. admit.
                     (*
                       This cannot be proven because the following may hold: [(x.+1 * y.+1)%N = q].
                       This is despite the fact that [prime q] because it could be that [x=0, y=q-1].
                      *)
           }

           - move => //=.

    Abort.

    (* Restart: Include the preconditions. *)

    Definition f' (a : 'Z_q) : 'Z_q -> 'Z_q :=
      fun b => Zp_mul b a.

    Definition f_inv' (a : 'Z_q) : 'Z_q -> 'Z_q :=
      fun c => Zp_mul c (Zp_inv a).

    (* Note that I cannot specify that [0 != b]. *)
    Lemma f_inj' : forall (a : 'Z_q),
        prime q ->
        (0 != a) ->
        cancel (f' a) (f_inv' a).
    Proof.
      case => na na_lt_q prime_q O_neq_na //=.
      rewrite /cancel/f'/f_inv' => //=.
      case => nb bb_lt_q //=.
      move: O_neq_na; rewrite eq_sym => O_neq_na.
      apply (mul_inv _ _ prime_q O_neq_na).
    Qed.

    Lemma f_inv_sur : forall (a : 'Z_q),
        prime q ->
        (0 != a) ->
        cancel (f_inv' a) (f' a).
    Proof.
      case => na na_lt_q prime_q //=.
      rewrite eq_sym => O_neq_na //=.
      rewrite /cancel/f_inv'/f'.
      case => b0 b0_lt_q.
      rewrite Zp_mulC Zp_mulA.
      rewrite [X in Zp_mul X _]Zp_mulC. (* See Contextual Patterns for rewrite. *)
      apply (mul_inv _ _ prime_q O_neq_na).
    Qed.

    Lemma f_bij :
      forall (a : 'Z_q),
        prime q ->
        (0 != a) ->
        bijective (f' a).
    Proof.
      move => a prime_q O_neq_a.
      exact
        (Bijective
           (f_inj' a prime_q O_neq_a)
           (f_inv_sur a prime_q O_neq_a)).
    Qed.

  End Zp_bij.



  (*
    Different approach: save it in the context instead of in the type!
   *)
  Definition my_f' (a : nat) (H : (0 < a)%N) : nat -> nat :=
    fun b => muln a b.

  Definition my_g' (a : nat) (H : (0 < a)%N) : nat -> nat :=
    fun c => divn c a.

  (* [H] is also not derivable because [p] is positive but not necessarily the
     number that was sampled from [p]. *)
  Lemma bij' : forall (a : nat) (H:(0 < a)%N), bijective (my_f' a H).
  Proof.
    intros.
    apply (@Bijective nat nat (my_f' a H) (my_g' a H)).
    - unfold cancel. unfold my_f'. unfold my_g'. intros.
      (* Search (((?X * ?Y) %/ ?X)%N). *) rewrite mulKn.
      1: { reflexivity. }
      assumption.
    - unfold cancel. unfold my_f'. unfold my_g'. intros.
      rewrite mulnC.
      rewrite divnK.
      1:{reflexivity.}
      (* Search ((_ %| _)%N). *) Locate "%|". Search dvdn. Print dvdn. unfold dvdn.
      (* Search ((_ %% _ = 0)%N). *)
      (*
        This does not work because the formula has the following form:
        [(x %/ m) * m].
        [%/] is the euclidean division.
        That is, I have to provide evidence that [x %| m == 0] or phrased
        differently: I have to show that there is no remainder in that division!
        And that I can not do.
       *)
  Abort.

(*
  Definition f (ab : Arit (uniform p) * Arit (uniform p)) : Arit (uniform p) :=
    let '(a, b) := ab in
    my_f (SNatc a, SNatc b).
 *)

  (*
  (*
    The below lemma is what we would need to prove.
   *)
  Lemma inv' : forall (x  y  xy  z: nat)
                 (x' y' xy'  : 'I_(x*y).+1), (* The inverse operation of multiplication needs to be on a group. *)
      xy = (x * y)%nat →  (* First direction: multiplication on natural numbers. *)
      x' = inZp x →
      y' = inZp y →     (* Second direction: division on natural numbers requires a detour via a group. *)
      xy' = inZp xy →
      z = (Zp_mul xy' (y' ^- 1)) →
      x = z.
  Proof.
    intros.
    rewrite H3 H2 H1.
    unfold Zp_mul.
    (*
      This feels to me like a very general lemma that should hold regardless
      of our special case here.
     *)
    Search inZp.
    rewrite <- Zp_mulrn.
    rewrite <- Zp_mulrn.
    rewrite Zp_expg.
    Search inZp.
    rewrite (valZpK (x*y)).
    rewrite <- Zp_mulrn.
    unfold "^-".
    unfold FinGroup.inv.
    simpl.
    Search "inv".
    Search "^+".
    Print mathcomp.algebra.zmodp.


    Lemma mul : forall (x y : nat) (x' y' xy'  : 'I_(x*y).+1),
        x' = inZp x →
        y' = inZp y →
        inZp (x' * y') = x * y.

  Definition f (a : Arit (uniform p)) : Arit (uniform (p * p)) → Arit (uniform p) * 'I_(a * p)%nat.+1 :=
     fun x =>
      let '(b,c) := ch2prod x in
      let d := (Zp_mul (inZp a) (inZp c)) in
      (b,d).
*)
(*
  Definition g (a : Arit (uniform p)) : Arit (uniform p) * 'I_(a * p)%nat.+1  → Arit (uniform (p * p)) :=
     fun x =>
      let '(b,d) := ch2prod x in
      let c := (Zp_mul (inZp a) (inZp c)) in
      fto (b,d).


  Lemma bijective_f : forall a, bijective (f a).
  Proof.
    intros.
    (* Search bijective. *)
    (* apply Bijective. *)
    Check bijective.
    Check Bijective.
    Check cancel.
    unfold f. simpl. unfold g'''. unfold g'. unfold g. simpl.
    admit.
    Admitted.
 *)


  Definition f_final (a : Arit (uniform p)): Arit (uniform p) -> Arit (uniform (p * p)) :=
    fun b =>
        let c := f' p (Aritp_Zp a) (Aritp_Zp b) in
        prod2ch (b, Zp_Aritp c).

  Definition f_final_inv (a : Arit (uniform p)) : Arit (uniform (p * p)) → Arit (uniform p) :=
    fun x =>
      let '(_,c) := ch2prod x in  (* I cannot just use the [b] that comes with the tuple because then I cannot prove bijectivity. *)
      Zp_Aritp (f_inv' p (Aritp_Zp a) (Aritp_Zp c)).

  Lemma f_final_f_final_inv (a : Arit (uniform p)) (uneq_0 : 0 != Aritp_Zp a) :
    forall x, f_final_inv a (f_final a x) = x.
  Proof.
    rewrite /f_final_inv/f_final => x //=.
    rewrite ch2prod_prod2ch //=.
    rewrite /Aritp_Zp/Zp_Aritp/Arit_Zp'/Zp_Arit' => //=.
    rewrite fromZp_intoZp.
    rewrite f_inj'.
    - by rewrite intoZp_fromZp.
    - exact prime_order.
    - exact uneq_0.
  Qed.

  Lemma f_final_inv_f_final (a : Arit (uniform p)) :
    forall x, f_final a (f_final_inv a x) = x.
  Proof.
    rewrite /f_final/f_final_inv => x //=.
    rewrite /Aritp_Zp/Zp_Aritp/Arit_Zp'/Zp_Arit' => //=.
  Abort.

  Lemma f_final_bij (a : Arit (uniform p)):
    bijective (f_final a).
  Proof.
  Admitted.

  Theorem DDH__security : ∀ L__A A,
      ValidPackage L__0 Game__Import Game__Export DH__real → (* 1st game pair package is valid *)
      ValidPackage L__1 Game__Import Game__Export DH__ideal → (* 2nd game pair package is valid *)
      ValidPackage L__A Game__Export A_export A → (* the valid attacker package *)
      fdisjoint L__A L__0 → (* the state of the attacker is disjoint to the state of 1st package of the game pair. *)
      fdisjoint L__A L__1 → (* the state of the attacker is disjoint to the state of 2nd package of the game pair. *)
      ɛ__DH A = 0. (* the attacker cannot distinguish between the two packages in the game. *)
  Proof.
    intros.
  (* Our goal now is to rewrite [epsilon__DH] with 0.
     The doc states:
     We need to prove a lemma of perfect indistinguishability of the two packages in the
     Game Pair.
   *)
    Check eq_rel_perf_ind_ignore.
    Check fsubset.
    eapply (eq_rel_perf_ind_ignore (fset [:: fk])). (* Invariant: heaps are subsets. *)
    - exact H.
    - exact H0.
    - apply ignored_is_subset.
    - simplify_eq_rel x.  (* [x] becomes the argument to the procedure. *)
      (* Check this state out in the editor!
         The proof actually reasons about the state via pre and post conditions.
         (Similar to Hoare logic.)
         Here, it is called a relational judgement.
       *)
      ssprove_code_simpl_more.
      (* The first two code steps are equal: *)
      ssprove_sync.
      intros.
      eapply r_assert.
      ssprove_sync.
      intros.
      (* This one now is more tricky.
         My strategy: I'm just going to delay dealing with the last sampling until the very end.
       *)
      ssprove_swap_rhs 0%N.
      ssprove_sync.
      ssprove_swap_rhs 0%N.
      ssprove_sync.
      (* Now, we have the differences between the two programs. *)
      (* I would like to get rid of the [get]s now.
         My strategy: I need to teach SSProve that [a = x0] and [a0 = x1].
         I want SSProve to remember that we wrote these values to the locations.
         This is only possible when I bring the code into a particular form where the
         [put] is followed immediately by a [get].
         I need to restart the proof.
       *)
      Restart.

    intros.
    eapply eq_rel_perf_ind_ignore.
    - exact H.
    - exact H0.
    - apply ignored_is_subset.
    - simplify_eq_rel x.
      ssprove_code_simpl_more.
      ssprove_sync. intros.
      ssprove_sync. intros.
      (* Remove the [get]s on the left-hand side. *)
      ssprove_swap_lhs 1%N. (* Now we have the proper form for [get] removal. *)
      ssprove_contract_put_get_lhs.
      ssprove_swap_rhs 0%N. (* Go away [sample]! *)
      ssprove_sync. (* 1st [put] gone. *)
      ssprove_contract_put_get_lhs. (* 2nd [get] gone. *)
      ssprove_swap_rhs 0%N. (* Go away [sample]! *)
      ssprove_sync. (* 2nd [put] gone. *)
      (* At this, we are left with the assertion (lhs) and the sampling (rhs). *)
      (*
        - There are rules still missing in SSProve. It would have helped to have
          a lemma that just kicks out assertions that are not used anywhere.
          I had to introduce the same assertion into the ideal version to make further progress.
        - I also had to store the final key into the state in the real version.
          The key lesson learned here is, if the states are different then we need to
          use the other invariant. But we cannot just use the same state and not use
          one of the state slots in one of the version. The problem that
          we are facing is that we cannot drop a lonely [put].
       *)
      eapply r_const_sample_R.
      + (* Search "LosslessOp". *) apply LosslessOp_uniform.
      + intros. eapply r_put_rhs.

        (* Careful here!
           It seems like a good idea to remove the [ret].
           But that also is the last command and will drop us
           from [≈] (perfect indistinguishability) into [=] (equality).

           Check out the steps below.
           We end up having to prove [(a0 * a)%N = x0] which is
           exactly the difference in the two programs.
           But this lemma cannot be proven!
           What we actually want to prove is [(a0 * a)%N ≈ x0].
           We want to state that these two sides are indistinguishable!

        eapply r_ret.
        intros. split.
        * apply f_equal. apply f_equal. apply f_equal.
          (* At this point, I'm basically at the core of the proof.
             I have to prove [g ^+ a0 ^+ a = g ^+ x0].
           *)
          (* Search "^+". *)
          rewrite <- expgM. apply f_equal.
          (* Reduced to a proof for [(a0 * a)%N = x0]. *)
          destruct x0. destruct a0. destruct a. simpl.
        * Search set_rhs. unfold set_rhs in H4. Search set_heap. inversion H4. destruct H5.
        *)

        (* Our goal is to finish off with [r_reflexivity], in fact
           stating that the computations on both sides are indistinguishable
           from each other for an attacker.
         *)
        eapply r_ret. intros. split.
        * repeat f_equal. Search "^+". 1: { rewrite <- expg1. f_equal. destruct a0. cbn. inversion i. admit.  } admit.
        * admit.
    - ssprove_valid.
    - auto.
    - auto.

      Restart.

    intros.
    eapply eq_rel_perf_ind_ignore.
    - exact H.
    - exact H0.
    - apply ignored_is_subset.
    - simplify_eq_rel x.
      ssprove_code_simpl_more.
      ssprove_sync. intros.

      (* Take care of the put/get combos. *)
      ssprove_swap_lhs 0%N.
      ssprove_swap_lhs 2%N.
      ssprove_swap_lhs 1%N.
      ssprove_contract_put_get_lhs.
      ssprove_swap_rhs 1%N.
      ssprove_swap_rhs 0%N.
      ssprove_sync.

      (* This pattern is only here to turn two distinct samples
         on the right-hand side into a single one.
       *)
      eapply r_transR.
      Check r_uniform_prod.
      1: { eapply r_uniform_prod. intros. eapply rreflexivity_rule. }

      simpl.

      (* Now we need to define a function that says, how we get from one variable on the
       left-hand side to a different (but by sampling connected) variable
       on the right-hand side. *)
      (* eapply rsymmetry. *)
      Check r_uniform_bij.
      Locate r_uniform_bij.
      eapply r_uniform_bij.
      Search (_ ^+ _ ^+ _).
      Search (_ ^- _).
      (*
        g ^+ n ^+ m = g ^+ (n * m)
        x1 := x0
        n := x1
        m := a

        y := x1 * a
        y := (fun x0: x0 * a) x0

        Zp :
        f a := (fun x0 : x0 * a)
        inv_f a := (fun y : y * a-1)

        f a := (fun x0 : get_exp (g ^+ x0 ^+ a))
        inv_f := (fun y: get_exp (g ^+ y ^- a) )

      Definition f     (a : Arit (uniform p)) : forall b:Arit (uniform p), b * 'Z_p
      Definition f_inv (a : Arit (uniform p)) : (Arit (uniform p)) * 'Z_p → Arit (uniform p)

      (*
        I may be on the wrong track here because
        Z_p * Z_p does not mean that I enter into Z_p again.
        But that is not a problem in fact.
        I can have :
        [Definition f : Z_{p}_{} → Z_{p}_{}_{} → Z_{p*p}]
        and the inverse operation:
        [Definition g : Z____{}_{p*p} → Z_{p}×Z_{p}_{}_{}]
        Or more general:
        [Definition f : Z___{i} → Z_{j}_{} → Z_{i*j}]
        and the inverse operation:
        [Definition g : Z_{i*j} → Z_{i}×Z_{j}_{}_{}]
       *)
      Check expgM.
      (*
      f (x1, a) = y
      g y = (x1, a)
       *)

      ssprove_sync. intros.
      (* Remove the [get]s on the left-hand side. *)



    - ssprove_valid.
    - auto.
    - auto.
       *)
  Admitted.


End DiffieHellmann.

