(** *Introduction

In order to get into SSProve, it makes sense to look at a "simple" protocol
implementation and its verification.
I took this file straight from 'ssprove/theories/Crypt/examples/SigmaProtocol.v' and copied it here such
that I/we can add comments that will help us to understand.
*)
From Relational Require Import OrderEnrichedCategory GenericRulesSimple.

Set Warnings "-notation-overridden,-ambiguous-paths".
From mathcomp Require Import all_ssreflect all_algebra reals distr realsum
  fingroup.fingroup solvable.cyclic prime ssrnat ssreflect ssrfun ssrbool ssrnum
  eqtype choice seq.
Set Warnings "notation-overridden,ambiguous-paths".


From Crypt Require Import Axioms ChoiceAsOrd SubDistr Couplings
  UniformDistrLemmas FreeProbProg Theta_dens RulesStateProb UniformStateProb
  pkg_core_definition choice_type pkg_composition pkg_rhl
  Package Prelude RandomOracle.

From Coq Require Import Utf8.
From extructures Require Import ord fset fmap.

From Equations Require Import Equations.
Require Equations.Prop.DepElim.

Set Equations With UIP.

Set Bullet Behavior "Strict Subproofs".
Set Default Goal Selector "!".
Set Primitive Projections.

Import Num.Def.
Import Num.Theory.
Import Order.POrderTheory.

Import PackageNotation.

#[local] Open Scope ring_scope.
Import GroupScope GRing.Theory.

(** Simple scheme: Diffie Hellmann Key Exchange

The scheme: A, B agree on prime p and element g \in group G = Z_p

    A:                          B:
sample a from G
A = g^a          ----A --->
                             sample b from G
                             B = g^b
                <----B-----
k=B^a                        k'=A^b

Lemma: k = k'
**)

Locate ">".
Print cycle_group. (* Has Notation <[ g ]> *)

Locate "#[".
Print order.

(*
  The math part:
 *)
Module Type GroupParams.

  (* Read:
https://math-comp.github.io/htmldoc/mathcomp.fingroup.fingroup.html
   *)
  Parameter gT : finGroupType.            (* We need a group type of finite size. *)
  Definition ζ : {set gT} := [set : gT].  (* The group [Z_p] is a set of type finite group type. *)
  Parameter g :  gT.                      (* This is the group element [g]. *)
  Parameter g_gen : ζ = <[g]>.            (* Predicate: [Z_p] is equal to the cyclic subgroup generated by [g]. *)
  Parameter prime_order : prime #[g].     (* Property: The order of the group generated from [g] is a prime number. *)

End GroupParams.

Module Type DiffieHellmannProtocolParams.

  Parameter Space: finType.
  Parameter Space_pos : Positive #|Space|.

End DiffieHellmannProtocolParams.


(*
  Here, we would define abstractions.
 *)
Module Type SigmaProtocolAlgorithms (DDHP : DiffieHellmannProtocolParams) (GP : GroupParams).

  Import DDHP.
  Import GP.

  #[local] Open Scope package_scope.

  #[local] Existing Instance Space_pos.

  (* We need to prove that #|GroupSpace| is positive. *)
  Definition GroupSpace : finType := FinGroup.arg_finType gT.
  #[local] Instance GroupSpace_pos : Positive #|GroupSpace|.
  Proof.
    apply /card_gt0P; by exists g.
  (* Needs to be transparent to unify with local positivity proof? *)
  Defined.

  Definition chGroup : choice_type := 'fin #|GroupSpace|.
  Notation " 'group " := (chGroup) (in custom pack_type at level 2).

  (* [p] itself is derived from the DiffieHellmann Parameters. *)
  Definition p := #|Space|.
  #[export] Instance p_pos : Positive p.
  Proof.
    unfold p. exact Space_pos.
  Defined.
  Definition chPElem : choice_type := 'fin p.

  Parameter Protocol_locs : {fset Location}.    (* | Here I will note all the steps of the protocol *)
  Parameter Simulator_locs : {fset Location}.   (* | This is for the simulator || not used yet *)

  (*
  Parameter Simulate :
    ∀ (g : choicePubKey) (sk_A : choicePrivKey) (sk_B : choicePrivKey),
      code Simulator_locs [interface] choiceTranscript.
   *)

End SigmaProtocolAlgorithms.

Module SigmaProtocol
  (DDHP : DiffieHellmannProtocolParams)
  (GP : GroupParams)
  (Alg : SigmaProtocolAlgorithms DDHP GP).

  Import Alg.
  Import GP. (* We actually only need [g], the group. *)

  (* This is a trick to give names to functions. *)
  Definition DDH : nat := 0.

  (* I want to store some elements of the group in the state. *)
  Definition sk_A : Location := (chPElem ; 0%N).
  Definition sk_B : Location := (chPElem ; 1%N).
  Definition fk : Location := (chPElem ; 2%N).

  (* Definition L__0 := fset [:: sk_A ; sk_B ; fk]. *)
  (* Using [L__0 ≔ fset[:: sk_A ; sk_B] ] here will make the proof more complicated because then
     we need to use another invariant over the heap. *)
  Definition L__0 := fset [:: sk_A ; sk_B].
  Definition L__1 := L__0 :|: fset [:: fk].

  #[local] Open Scope package_scope.

  Print fto.

  (* We need these definitions multiple times below.
     So just define them once here.
     Note that a game package needs to export a procedure of type ['unit → t] where [t] is some choice type.
   *)
  Definition Game__Import : Interface := [interface].
  Definition Game__Export : Interface := [interface #val #[ DDH ] : 'unit → 'group × 'group × 'group].

  Definition DH__real:
    package L__0
      Game__Import Game__Export
  :=
  [package
    #def #[ DDH ] (_ : 'unit) : 'group × 'group × 'group
    {
      (* Initially the state locations are empty. Let's fill them: *)
      sk_alice ← sample uniform p ;;
      sk_bob ← sample uniform p ;;
      #put sk_A := sk_alice ;;
      #put sk_B := sk_bob ;;

      (* Now, let's start with the protocol. *)

      (* Alice side: ephemeral key gen *)
      sk_alice' ← get sk_A ;;
      let e_a := (g^+ sk_alice') in

      (* Bob side: ephemeral key gen *)
      sk_bob' ← get sk_B ;;
      let e_b := (g^+ sk_bob') in

      (*
        If we want to model this properly then we would also have a state
        for the communication between Alice and Bob.
        Right now, the [Send_EphKey] function does not make much sense.
        It is essentially just [id].
       *)
      (*
      e_a_at_bob ← Send_EphKey e_a ;;
      e_b_at_alice ← Send_EphKey e_b ;;
       *)
      let e_a_at_bob := e_a in
      let e_b_at_alice := e_b in

      (* Alice side: final key gen *)
      let fk_alice := (e_b_at_alice^+ sk_alice') in

      (* Bob side: final key gen *)
      let fk_bob := (e_a_at_bob^+ sk_bob') in

      (* To reason about the correctness of the protocol/program
         just use assertions (of type [bool] not [Prop]!):
       *)
      (*
      [assert (fk_alice == fk_bob) ;;]
      Lesson learned: Don't define assertions that you do not use later on the code.
      The "ideal" package will need to define those too.
       *)

      (* Lesson learned:
         If the states look the same then I have to treat them in the same way.
         It is currently not possible to remove "lonely" [put] calls.

         I cannot put [fk_alice] blindly because obviously the type is not the
         same as for yet another value sampled from the distribution.
         [#put fk := fk_alice ;;]
       *)

      (* Our output here is essentially our communication, i.e.,
         everything that the attacker should be able to see but hopefully
         not be able to recover.
       *)
      ret (fto e_a , (fto e_b, fto fk_alice))
    }
  ].

  (** *** Simulated implementation
      Here, we really remove all the noise and just perform the mathematic
      operations.
   *)

  Lemma sk_A_in_L__1: sk_A \in L__1.
  Proof.
    unfold L__1. unfold L__0. (* Search "in_fset". *)
    rewrite in_fsetU. (* Locate "||". Print orb. Search "fset". *)
    apply /orP. left.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite in_fset1.
    apply /eqP.
    reflexivity.
  Qed.

  Lemma sk_B_in_L__1: sk_B \in L__1.
  Proof.
    unfold L__1. unfold L__0.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. right.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite in_fset1.
    apply /eqP.
    reflexivity.
  Qed.

  Lemma fk_in_L__1: fk \in L__1.
  Proof.
    unfold L__1. unfold L__0.
    rewrite in_fsetU.
    apply /orP. right.
    rewrite fset_cons.
    rewrite in_fsetU.
    apply /orP. left.
    rewrite in_fset1.
    apply /eqP.
    reflexivity.
  Qed.


  Definition DH__ideal: package L__1 Game__Import Game__Export.
    refine(
        [package
           #def #[ DDH ] (_ : 'unit) : 'group × 'group × 'group
           {
             a ← sample uniform p ;;
             b ← sample uniform p ;;
             c ← sample uniform p ;;

             #put sk_A := a ;;
             #put sk_B := b ;;
             (* This was interesting:
                When not putting [c] into the state, I received a cryptic error message.
                It seems everything that was sampled needs to go into the state otherwise
                the package is not valid.
              *)
             #put fk := c ;;

             (* We are saying the an attacker would not be able to differentiate between
                our computed result and a randomly chosen one. *)
             ret (fto (g^+ a), (fto (g^+ b), fto (g^+ c)))
         }
      ]).
     ssprove_valid.
    - apply sk_A_in_L__1.
    - apply sk_B_in_L__1.
    - apply fk_in_L__1 .
  Defined.

  (* There is also a way to package a defined ValidCode into a ValidPackage.
     This does not work in the above case because the return type differ.
   *)
  Equations ddh_ideal : code L__1 [interface]
                     (prod_choiceType
                        (prod_choiceType
                           (FinGroup.choiceType gT)
                           (FinGroup.choiceType gT))
                        (FinGroup.choiceType gT)) :=
  ddh_ideal := {code
           a ← sample uniform p ;;
           b ← sample uniform p ;;
           c ← sample uniform p ;;

           #put sk_A := a ;;
           #put sk_B := b ;;
           #put fk := c ;;

           ret ((g^+ a), (g^+ b), (g^+ c))
      }.
  Next Obligation.
    ssprove_valid.
    - apply sk_A_in_L__1.
    - apply sk_B_in_L__1.
    - apply fk_in_L__1 .
  Defined.

  (* It is also possible to extend the ssprove_valid db
     with hints for the lemmas.
   *)

  Check AdvantageE.

  (*
    Now, I can define an advantage, i.e., a game.
    An attacker (package) [A] can not distinguish between the two (package) versions.
   *)
  Definition ɛ__DH A := AdvantageE DH__real DH__ideal A.

  (* The exported interface for running the game via the attacker package is
     predefined for us by SSProve.
   *)
  Check A_export.

  Lemma ignored_is_subset : fsubset (fset [:: fk]) (L__0 :|: L__1).
  Proof.
    unfold fsubset. rewrite fset_cons. unfold L__1. rewrite <- fset0E. rewrite fsetUC.
    rewrite fsetUA. rewrite fset_cons. rewrite <- fset0E. rewrite fsetU0.
    rewrite fsetUA. rewrite fset1E. rewrite fsetUA. rewrite fsetU0.
    rewrite fsetUid. rewrite fset_cons. rewrite <- fset0E. rewrite fsetUC. rewrite fsetUA.
    rewrite fsetUC. rewrite fsetUA.
    rewrite fsetUid. rewrite fsetUC.
    apply /eqP.
    reflexivity.
  Qed.
(*
  Lemma perf_ind_arit :
    ∀ {A B: choiceType} c0 c1 (pre : precond) (post : postcond A A) (a a0 x0 : Arit (uniform p)),
      ⊢ ⦃ pre ⦄ c0 (g ^+ x0) ≈ c1 (g ^+ x0) ⦃ post ⦄ →
      ⊢ ⦃ pre ⦄ c0 (g ^+ a0 ^+ a) ≈ c1 (g ^+ x0) ⦃ post ⦄.
 *)


  Search "^+".
  Search expgn_rec.

  (*
    fto : fin-to-option
    otf : option-to-fin
   *)

  Check (Finite.sort DDHP.Space).

  (* Understanding the types. *)
  Definition g    (a : Arit (uniform p)) : DDHP.Space := otf a.
  Definition g'   (a : DDHP.Space) : 'fin p := fto a.
  Definition g''  (a : 'fin p) : nat := ('I_p a * 'I_p a)%nat.
  Definition g''' (a : Arit (uniform p)) : nat := 'I_p (g' (g a)).
  (* I need the inverse function of g⁗.
     For that, I need to preserve [p].
   *)
  (*
  Definition g'''' (a : Arit (uniform p)) : 'fin (p * p) := ('I_p a * 'I_p a)%nat.
   *)
  (*
    I want to apply expgM!
   *)
  Definition f (a : Arit (uniform p)) : Arit (uniform (p * p)) → Arit (uniform p) * nat :=
     fun x =>
      let '(b,c) := ch2prod x in
      let d := ((g''' a) * (g''' c))%nat in (* 'fin (a * c) *)
      (b,d).

  (* Search nat. Print divn. *)
  (*
  Definition h (a : Arit (uniform p)) : Arit (uniform p) * nat → Arit (uniform (p * p)) :=
                  fun x =>
                    let '(b,n) := x in
                    chProd (b, divn n a).
   *)
  Lemma bijective_f : forall a, bijective (f a).
  Proof.
    intros.
    (* Search bijective. *)
    (* apply Bijective. *)
    Check bijective.
    Check Bijective.
    Check cancel.
    unfold f. simpl. unfold g'''. unfold g'. unfold g. simpl.
    admit.
    Admitted.

  Theorem DDH__security : ∀ L__A A,
      ValidPackage L__0 Game__Import Game__Export DH__real → (* 1st game pair package is valid *)
      ValidPackage L__1 Game__Import Game__Export DH__ideal → (* 2nd game pair package is valid *)
      ValidPackage L__A Game__Export A_export A → (* the valid attacker package *)
      fdisjoint L__A L__0 → (* the state of the attacker is disjoint to the state of 1st package of the game pair. *)
      fdisjoint L__A L__1 → (* the state of the attacker is disjoint to the state of 2nd package of the game pair. *)
      ɛ__DH A = 0. (* the attacker cannot distinguish between the two packages in the game. *)
  Proof.
    intros.
  (* Our goal now is to rewrite [epsilon__DH] with 0.
     The doc states:
     We need to prove a lemma of perfect indistinguishability of the two packages in the
     Game Pair.
   *)
    Check eq_rel_perf_ind_ignore.
    Check fsubset.
    eapply (eq_rel_perf_ind_ignore (fset [:: fk])). (* Invariant: heaps are subsets. *)
    - exact H.
    - exact H0.
    - apply ignored_is_subset.
    - simplify_eq_rel x.  (* [x] becomes the argument to the procedure. *)
      (* Check this state out in the editor!
         The proof actually reasons about the state via pre and post conditions.
         (Similar to Hoare logic.)
         Here, it is called a relational judgement.
       *)
      ssprove_code_simpl_more.
      (* The first two code steps are equal: *)
      ssprove_sync.
      intros.
      ssprove_sync.
      intros.
      (* This one now is more tricky.
         My strategy: I'm just going to delay dealing with the last sampling until the very end.
       *)
      ssprove_swap_rhs 0%N.
      ssprove_sync.
      ssprove_swap_rhs 0%N.
      ssprove_sync.
      (* Now, we have the differences between the two programs. *)
      (* I would like to get rid of the [get]s now.
         My strategy: I need to teach SSProve that [a = x0] and [a0 = x1].
         I want SSProve to remember that we wrote these values to the locations.
         This is only possible when I bring the code into a particular form where the
         [put] is followed immediately by a [get].
         I need to restart the proof.
       *)
      Restart.

    intros.
    eapply eq_rel_perf_ind_ignore.
    - exact H.
    - exact H0.
    - apply ignored_is_subset.
    - simplify_eq_rel x.
      ssprove_code_simpl_more.
      ssprove_sync. intros.
      ssprove_sync. intros.
      (* Remove the [get]s on the left-hand side. *)
      ssprove_swap_lhs 1%N. (* Now we have the proper form for [get] removal. *)
      ssprove_contract_put_get_lhs.
      ssprove_swap_rhs 0%N. (* Go away [sample]! *)
      ssprove_sync. (* 1st [put] gone. *)
      ssprove_contract_put_get_lhs. (* 2nd [get] gone. *)
      ssprove_swap_rhs 0%N. (* Go away [sample]! *)
      ssprove_sync. (* 2nd [put] gone. *)
      (* At this, we are left with the assertion (lhs) and the sampling (rhs). *)
      (*
        - There are rules still missing in SSProve. It would have helped to have
          a lemma that just kicks out assertions that are not used anywhere.
          I had to introduce the same assertion into the ideal version to make further progress.
        - I also had to store the final key into the state in the real version.
          The key lesson learned here is, if the states are different then we need to
          use the other invariant. But we cannot just use the same state and not use
          one of the state slots in one of the version. The problem that
          we are facing is that we cannot drop a lonely [put].
       *)
      eapply r_const_sample_R.
      + (* Search "LosslessOp". *) apply LosslessOp_uniform.
      + intros. eapply r_put_rhs.

        (* Careful here!
           It seems like a good idea to remove the [ret].
           But that also is the last command and will drop us
           from [≈] (perfect indistinguishability) into [=] (equality).

           Check out the steps below.
           We end up having to prove [(a0 * a)%N = x0] which is
           exactly the difference in the two programs.
           But this lemma cannot be proven!
           What we actually want to prove is [(a0 * a)%N ≈ x0].
           We want to state that these two sides are indistinguishable!

        eapply r_ret.
        intros. split.
        * apply f_equal. apply f_equal. apply f_equal.
          (* At this point, I'm basically at the core of the proof.
             I have to prove [g ^+ a0 ^+ a = g ^+ x0].
           *)
          (* Search "^+". *)
          rewrite <- expgM. apply f_equal.
          (* Reduced to a proof for [(a0 * a)%N = x0]. *)
          destruct x0. destruct a0. destruct a. simpl.
        * Search set_rhs. unfold set_rhs in H4. Search set_heap. inversion H4. destruct H5.
        *)

        (* Our goal is to finish off with [r_reflexivity], in fact
           stating that the computations on both sides are indistinguishable
           from each other for an attacker.
         *)
        eapply r_ret. intros. split.
        * repeat f_equal. Search "^+". 1: { rewrite <- expg1. f_equal. destruct a0. cbn. inversion i. admit.  } admit.
        * admit.
    - ssprove_valid.
    - auto.
    - auto.

      Restart.

    intros.
    eapply eq_rel_perf_ind_ignore.
    - exact H.
    - exact H0.
    - apply ignored_is_subset.
    - simplify_eq_rel x.
      ssprove_code_simpl_more.
      ssprove_sync. intros.

      (* Take care of the put/get combos. *)
      ssprove_swap_lhs 0%N.
      ssprove_swap_lhs 2%N.
      ssprove_swap_lhs 1%N.
      ssprove_contract_put_get_lhs.
      ssprove_swap_rhs 1%N.
      ssprove_swap_rhs 0%N.
      ssprove_sync.

      eapply r_transR.
      Check r_uniform_prod.
      1: { eapply r_uniform_prod. intros. eapply rreflexivity_rule. }
      simpl.
      eapply @r_uniform_bij with (f := f a).
      (*
        I may be on the wrong track here because
        Z_p * Z_p does not mean that I enter into Z_p again.
        But that is not a problem in fact.
        I can have :
        [Definition f : Z_{p}_{} → Z_{p}_{}_{} → Z_{p*p}]
        and the inverse operation:
        [Definition g : Z____{}_{p*p} → Z_{p}×Z_{p}_{}_{}]
        Or more general:
        [Definition f : Z___{i} → Z_{j}_{} → Z_{i*j}]
        and the inverse operation:
        [Definition g : Z_{i*j} → Z_{i}×Z_{j}_{}_{}]
       *)
      Check expgM.
      (*
      f (x1, a) = y
      g y = (x1, a)
       *)

      ssprove_sync. intros.
      (* Remove the [get]s on the left-hand side. *)



    - ssprove_valid.
    - auto.
    - auto.

  Admitted.


End SigmaProtocol.

